Групповое/парное программирование

1. Есть условный тимлид (делает каркас, заводит задачи на github и распределяет их среди коллег) 
2. Кто-то один работает над своей задачей, а остальные или один человек смотрит его демонстрацию экрана и пытаются помочь 
3. Работа в одном репозитории но на разных ветках
4. После завершения задачи, надо опубликовать изменения и открыть пулл реквест

---

На основе базового класса Pokemon написать свои классы для заданных видов покемонов. 
Каждый вид покемона должен иметь стандартные базовые характеристики:

    очки здоровья (HP) (задавать из параметров конструктора дочернего класса, double)
    атака (attack) (задавать из параметров конструктора дочернего класса, double)
    защита (defense) (задавать из параметров конструктора дочернего класса, double)
    специальная атака (special attack) (одна из атак с карточки из картинки)
    имя (name) (из заглавия карточки, прописываем прямо в конструкторе)

Реализуйте методы fight и sleep

Заставьте их драться и спать. 

В самой простой версии методы fight(), sleep() должны выводить информацию о происходящем.

Если останется время: создайте класс Battle, запустите сражение с любым сценария, 
посчитать итоговые результаты сражения. 

При сражении надо менять состояние (например уменьшать hp). При сне надо увеличивать 
hp на какую то долю.

---

Что надо сделать (краткое описание):

1. Написать классы покемонов
2. Написать класс Battle
3. Написать работающую программу и посмотреть как она работает.
    ```java
        Battle b = new Battle();
        Pokemon p1 = new Pokemon("Чужой", 1);
        Pokemon p2 = new Pokemon("Хищник", 1);
        b.addToLeftTeam(p1);
        b.addToRightTeam(p2);
        b.go();
    ```
4. Если останется время: использовать какую либо коллекцию для хранения покемонов разных команд
5. Если останется время: написать разные сценарии сражений (разные жеребьевки)


---

Сценарий командной работы над одним репозиторием:

1. постановка задачи (issue) и определение исполнителя
2. выполнение задачи на отдельной ветке исполнителем
3. создание pull request'а исполнителем и выставление ревьюера в pull request'е
4. ревьюера ставит approve
5. опциально: approve от тестировщика
6. pull request сливают
7. закрывают issue